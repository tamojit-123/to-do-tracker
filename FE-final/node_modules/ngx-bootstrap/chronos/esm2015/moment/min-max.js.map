{"version":3,"file":"min-max.js","sourceRoot":"","sources":["../../../../../src/chronos/moment/min-max.ts"],"names":[],"mappings":"AAAA,oEAAoE;AACpE,0DAA0D;AAC1D,EAAE;AACF,yEAAyE;AACzE,+CAA+C;AAC/C,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAC5D,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAG1D,SAAS,MAAM,CAAC,EAA0D,EAAE,KAAwB;IAClG,IAAI,MAAc,CAAC;IACnB,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAI,OAAO,CAAO,SAAS,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAClD,MAAM,GAAG,SAAS,CAAC;KACpB;SAAM,IAAI,OAAO,CAAO,KAAK,CAAC,EAAE;QAC/B,MAAM,GAAG,KAAK,CAAC;KAChB;IAED,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;QAC7B,OAAO,IAAI,IAAI,EAAE,CAAC;KACnB;IACD,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QACtC,sDAAsD;QACtD,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;YAC5D,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACjB;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED,6BAA6B;AAC7B,MAAM,UAAU,GAAG,CAAC,GAAG,IAAY;IACjC,4CAA4C;IAE5C,OAAO,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,MAAM,UAAU,GAAG,CAAC,GAAG,IAAY;IACjC,4CAA4C;IAE5C,OAAO,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC/B,CAAC","sourcesContent":["// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nimport { isArray, isDateValid } from '../utils/type-checks';\nimport { isAfter, isBefore } from '../utils/date-compare';\nimport { UnitOfTime } from '../types';\n\nfunction pickBy(fn: (date: Date, date2: Date, unit: UnitOfTime) => boolean, dates: Date[] | Date[][]): Date {\n  let _dates: Date[];\n  const _firstArg = dates[0];\n  if (isArray<Date>(_firstArg) && dates.length === 1) {\n    _dates = _firstArg;\n  } else if (isArray<Date>(dates)) {\n    _dates = dates;\n  }\n\n  if (!_dates || !_dates.length) {\n    return new Date();\n  }\n  let res = _dates[0];\n  for (let i = 1; i < _dates.length; ++i) {\n    // if (!moments[i].isValid() || moments[i][fn](res)) {\n    if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {\n      res = _dates[i];\n    }\n  }\n\n  return res;\n}\n\n// TODO: Use [].sort instead?\nexport function min(...args: Date[]): Date {\n  // const args = [].slice.call(arguments, 0);\n\n  return pickBy(isBefore, args);\n}\n\nexport function max(...args: Date[]): Date {\n  // const args = [].slice.call(arguments, 0);\n\n  return pickBy(isAfter, args);\n}\n"]}