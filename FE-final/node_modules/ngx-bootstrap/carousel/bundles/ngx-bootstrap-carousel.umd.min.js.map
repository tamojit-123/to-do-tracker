{"version":3,"sources":["../../../tslib/tslib.es6.js","../../../../src/carousel/carousel.component.ts","../../../../src/carousel/carousel.config.ts","../../../../src/carousel/utils.ts","../../../../src/carousel/slide.component.ts","../../../../src/carousel/carousel.module.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","Direction","this","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","Injectable","args","providedIn","_currentId","CarouselComponent","config","ngZone","isAnimated","activeSlideChange","EventEmitter","slideRangeChange","startFromIndex","_interval","_slides","LinkedList","_currentVisibleSlidesIndex","isPlaying","destroyed","currentId","getActive","slide","active","makeSlidesConsistent","slides","forEach","index","item","order","assign","defineProperty","prototype","_currentActiveSlide","multilist","_select","restartTimer","toArray","isBs3","getBsVer","ngAfterViewInit","_this","setTimeout","_chunkedSlides","array","size","out","Math","ceil","chunk","splice","chunkByNumber","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","activeSlide","play","removeSlide","remIndex","indexOf","nextSlideIndex_1","isLast","remove","currentSlideIndex_1","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","nextSlide","previousSlide","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","predicate","l","findLastIndex","direction","firstVisibleIndex","lastVisibleIndex","moveMultilist","findNextSlideIndex","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlide","selectSlideRange","pause","isFirst","indicatorsSlides","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","getVisibleIndexes","nextSlideIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","setInterval","nInterval","run","clearInterval","Component","selector","template","CarouselConfig","NgZone","Input","Output","SlideComponent","carousel","itemWidth","addClass","ngOnInit","host","HostBinding","type","CarouselModule","forRoot","ngModule","providers","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output, AfterViewInit\n} from '@angular/core';\n\nimport { isBs3, LinkedList, getBsVer, IBsVersion } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { findLastIndex, chunkByNumber } from './utils';\nimport { SlideWithIndex, IndexedSlideList } from './models';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\nlet _currentId = 1;\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements AfterViewInit, OnDestroy {\n  /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap = false;\n  /*  If `true` — will disable pausing on carousel mouse hover */\n  @Input() noPause = false;\n  /*  If `true` — carousel-indicators are visible  */\n  @Input() showIndicators = true;\n  /*  If `true` - autoplay will be stopped on focus */\n  @Input() pauseOnFocus = false;\n  /* If `true` - carousel indicators indicate slides chunks\n     works ONLY if singleSlideOffset = FALSE */\n  @Input() indicatorsByChunk = false;\n  /* If value more then 1 — carousel works in multilist mode */\n  @Input() itemsPerSlide = 1;\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n     of visible elements (itemsPerSlide field) */\n  @Input() singleSlideOffset = false;\n  /** Turn on/off animation. Animation doesn't work for multilist carousel */\n  @Input() isAnimated = false;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange = new EventEmitter<number>(false);\n\n  /** Will be emitted when active slides has been changed in multilist mode */\n  @Output()\n  slideRangeChange = new EventEmitter<number[]|void>();\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this.multilist) {\n      return;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide || 0;\n  }\n\n  /* Index to start display slides from it */\n  @Input()\n  startFromIndex = 0;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  protected currentInterval?: number;\n  protected _currentActiveSlide?: number;\n  protected _interval = 5000;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected _chunkedSlides?: SlideWithIndex[][];\n  protected _slidesWithIndexes?: SlideWithIndex[];\n  protected _currentVisibleSlidesIndex = 0;\n  protected isPlaying = false;\n  protected destroyed = false;\n  currentId = 0;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  get _bsVer(): IBsVersion {\n    return getBsVer();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n\n  ngAfterViewInit(): void {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(\n          this.mapSlidesAndIndexes(),\n          this.itemsPerSlide\n        );\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false): void {\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex(): number {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex(): number {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  getActive = (slide: SlideComponent) => slide.active;\n\n  move(direction: Direction, force = false): void {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (\n        direction === Direction.NEXT &&\n        this.isLast(lastVisibleIndex) ||\n        direction === Direction.PREV &&\n        firstVisibleIndex === 0\n      ) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event: KeyboardEvent) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n\n      return;\n    }\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n\n      return;\n    }\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n\n      return;\n    }\n  }\n\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn(): void {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut(): void {\n    this.play();\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex(this.getActive);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index: number): boolean {\n    return index === 0;\n  }\n\n  indicatorsSlides(): SlideComponent[] {\n    return this.slides.filter(\n      (slide: SlideComponent, index: number) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0\n    );\n  }\n\n  private selectInitialSlides(): void {\n    const startIndex = this.startFromIndex <= this._slides.length\n      ? this.startFromIndex\n      : 0;\n\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes = [\n          ...this._slidesWithIndexes,\n          ...slidesToAppend\n        ]\n          .slice(slidesToAppend.length)\n          .slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(\n          startIndex,\n          startIndex + this.itemsPerSlide\n        );\n      }\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number | void {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n        nextSlideIndex = this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  private mapSlidesAndIndexes(): SlideWithIndex[] {\n    return this.slides\n      .slice()\n      .map((slide: SlideComponent, index: number) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n  }\n\n\n  private selectSlideRange(index: number): void {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index)\n        ? index\n        : index - this.itemsPerSlide + 1;\n\n      const endIndex = this.isIndexOnTheEdges(index)\n        ? index + this.itemsPerSlide\n        : index + 1;\n\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  private selectRangeByNestedIndex(index: number): void {\n    if (!this._chunkedSlides) {\n      return;\n    }\n\n    const selectedRange = this._chunkedSlides\n      .map((slidesList, i: number) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      })\n      .find(\n        (slidesList: IndexedSlideList) => {\n          return slidesList.list.find(slide => slide.index === index) !== undefined;\n        }\n      );\n\n    if (!selectedRange) {\n      return;\n    }\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach((slide: SlideWithIndex) => {\n      slide.item.active = true;\n    });\n  }\n\n  private isIndexOnTheEdges(index: number): boolean {\n    return (\n      index + 1 - this.itemsPerSlide <= 0 ||\n      index + this.itemsPerSlide <= this._slides.length\n    );\n  }\n\n  private isIndexInRange(index: number): boolean {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return (\n      index <= this.getLastVisibleIndex() &&\n      index >= this.getFirstVisibleIndex()\n    );\n  }\n\n  private hideSlides(): void {\n    this.slides.forEach((slide: SlideComponent) => slide.active = false);\n  }\n\n  private isVisibleSlideListLast(): boolean {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  private isVisibleSlideListFirst(): boolean {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  private moveSliderByOneItem(direction: Direction): void {\n    let firstVisibleIndex: number;\n    let lastVisibleIndex: number;\n    let indexToHide: number;\n    let indexToShow: number;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n\n      indexToHide = direction === Direction.NEXT\n        ? firstVisibleIndex\n        : lastVisibleIndex;\n\n      indexToShow = direction !== Direction.NEXT\n        ? firstVisibleIndex - 1\n        : !this.isLast(lastVisibleIndex)\n          ? lastVisibleIndex + 1 : 0;\n\n      const slideToHide = this._slides.get(indexToHide);\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n\n      const slideToShow = this._slides.get(indexToShow);\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n        (slide: SlideWithIndex) => slide.item.active\n      );\n\n      this.makeSlidesConsistent(slidesToReorder);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n\n    let index: number;\n\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n\n      index = this.isLast(lastVisibleIndex)\n        ? 0\n        : lastVisibleIndex + 1;\n\n      const item = this._slides.get(index);\n\n      if (item) {\n        this._slidesWithIndexes.push({ index, item });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n      index = this.isFirst(firstVisibleIndex)\n        ? this._slides.length - 1\n        : firstVisibleIndex - 1;\n\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\n      }\n    }\n\n    this.hideSlides();\n\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n\n    this.slideRangeChange.emit(\n      this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index)\n    );\n  }\n\n  private makeSlidesConsistent = (slides: SlideWithIndex[]): void => {\n    slides.forEach((slide: SlideWithIndex, index: number) => slide.item.order = index);\n  };\n\n  private moveMultilist(direction: Direction): void {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT\n          ? this._currentVisibleSlidesIndex + 1\n          : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n          ? 0\n          : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides\n            ? this._chunkedSlides.length - 1\n            : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n          (slide: SlideWithIndex) => slide.item.active = true\n        );\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  private getVisibleIndexes(): number[] | void {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex]\n        .map((slide: SlideWithIndex) => slide.index);\n    }\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n    }\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular<number>(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist(): boolean {\n    return this.itemsPerSlide > 1;\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CarouselConfig {\n  /* Default interval of auto changing of slides */\n  interval = 5000;\n\n  /* Is loop of auto changing of slides can be paused */\n  noPause = false;\n\n  /* Is slides can wrap from the last to the first slide */\n  noWrap = false;\n\n  /* Show carousel-indicators */\n  showIndicators = true;\n\n  /* Slides can be paused on focus */\n  pauseOnFocus = false;\n\n  /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n  indicatorsByChunk = false;\n\n  /* If value more then 1 — carousel works in multilist mode */\n  itemsPerSlide = 1;\n\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n    of visible elements (itemsPerSlide field) */\n  singleSlideOffset = false;\n}\n","/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nexport function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nexport function chunkByNumber<T>(array: T[], size: number): T[][] {\n  const out = [];\n  const n = Math.ceil((array.length) / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(\n      0,\n      (i === n - 1) && size < array.length ? array.length : size\n    );\n\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n","import {\n  Component,\n  HostBinding,\n  OnDestroy,\n  Input,\n  OnInit\n} from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\n\n@Component({\n  selector: 'slide',\n  template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n  host: {\n    '[attr.aria-hidden]': '!active'\n  },\n  styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n    :host.carousel-item {\n      margin-right: auto;\n    }\n  `]\n})\nexport class SlideComponent implements OnInit, OnDestroy {\n  /** Is current slide active */\n  @HostBinding('class.active')\n  @Input()\n  active = false;\n\n  @HostBinding('style.width') itemWidth = '100%';\n  @HostBinding('style.order') order = 0;\n  @HostBinding('class.carousel-animation') isAnimated = false;\n\n  /** Wraps element by appropriate CSS classes */\n  @HostBinding('class.item')\n  @HostBinding('class.carousel-item')\n  addClass = true;\n\n  /** Link to Parent(container-collection) component */\n  protected carousel: CarouselComponent;\n\n  constructor(carousel: CarouselComponent) {\n    this.carousel = carousel;\n  }\n\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit(): void {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy(): void {\n    this.carousel.removeSlide(this);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\nimport { SlideComponent } from './slide.component';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [SlideComponent, CarouselComponent],\n  exports: [SlideComponent, CarouselComponent]\n})\nexport class CarouselModule {\n  static forRoot(): ModuleWithProviders<CarouselModule> {\n    return { ngModule: CarouselModule, providers: [] };\n  }\n}\n"]}