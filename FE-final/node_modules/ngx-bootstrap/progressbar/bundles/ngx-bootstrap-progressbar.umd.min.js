!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("ngx-bootstrap/utils"),require("@angular/common")):"function"==typeof define&&define.amd?define("ngx-bootstrap/progressbar",["exports","@angular/core","ngx-bootstrap/utils","@angular/common"],t):t(((e="undefined"!=typeof globalThis?globalThis:e||self)["ngx-bootstrap"]=e["ngx-bootstrap"]||{},e["ngx-bootstrap"].progressbar={}),e.ng.core,e.utils,e.ng.common)}(this,(function(e,t,r,n){"use strict";var a=function(){function e(e,t){this.el=e,this.renderer=t,this.max=100,this.value=0,this.animate=!1,this.striped=!1,this.type="info",this.percent=100}return Object.defineProperty(e.prototype,"isBs3",{get:function(){return r.isBs3()},enumerable:!1,configurable:!0}),e.prototype.ngOnChanges=function(e){var t;(e.value||e.max)&&(this.percent=Number(e.value.currentValue||0)/Number((null===(t=e.max)||void 0===t?void 0:t.currentValue)||this.max||100)*100),e.type&&this.applyTypeClasses()},e.prototype.applyTypeClasses=function(){if(this._prevType){var e="progress-bar-"+this._prevType,t="bg-"+this._prevType;this.renderer.removeClass(this.el.nativeElement,e),this.renderer.removeClass(this.el.nativeElement,t),this._prevType=void 0}if(this.type){e="progress-bar-"+this.type,t="bg-"+this.type;this.renderer.addClass(this.el.nativeElement,e),this.renderer.addClass(this.el.nativeElement,t),this._prevType=this.type}},e}();a.decorators=[{type:t.Component,args:[{selector:"bar",template:"<ng-content></ng-content>\n",changeDetection:t.ChangeDetectionStrategy.OnPush,host:{role:"progressbar","aria-valuemin":"0","[class.progress-bar]":"true","[class.progress-bar-animated]":"!isBs3 && animate","[class.progress-bar-striped]":"striped","[class.active]":"isBs3 && animate","[attr.aria-valuenow]":"value","[attr.aria-valuetext]":'percent ? percent.toFixed(0) + "%" : ""',"[attr.aria-valuemax]":"max","[style.height.%]":'"100"',"[style.width.%]":"percent"}}]}],a.ctorParameters=function(){return[{type:t.ElementRef},{type:t.Renderer2}]},a.propDecorators={max:[{type:t.Input}],value:[{type:t.Input}],animate:[{type:t.Input}],striped:[{type:t.Input}],type:[{type:t.Input}]};var s=function(){this.animate=!1,this.max=100};s.ɵprov=t.ɵɵdefineInjectable({factory:function(){return new s},token:s,providedIn:"root"}),s.decorators=[{type:t.Injectable,args:[{providedIn:"root"}]}];var o=function(){function e(e){this.max=100,this.animate=!1,this.striped=!1,this.isStacked=!1,this._value=0,Object.assign(this,e)}return Object.defineProperty(e.prototype,"value",{set:function(e){this.isStacked=Array.isArray(e),"number"==typeof e?(this._value=e,this._values=void 0):(this._value=void 0,this._values=e)},enumerable:!1,configurable:!0}),e}();o.decorators=[{type:t.Component,args:[{selector:"progressbar",template:'<ng-container *ngIf="!isStacked then NotStacked else Stacked"></ng-container>\n\n<ng-template #NotStacked>\n  <bar [type]="type" [value]="_value" [max]="max" [animate]="animate" [striped]="striped">\n    <ng-content></ng-content>\n  </bar>\n</ng-template>\n\n<ng-template #Stacked>\n  <bar *ngFor="let item of _values"\n       [type]="item.type" [value]="item.value" [max]="item.max" [animate]="animate" [striped]="striped">{{ item.label }}</bar>\n</ng-template>\n',changeDetection:t.ChangeDetectionStrategy.OnPush,host:{"[class.progress]":"true","[attr.max]":"max"},styles:["\n    :host {\n      width: 100%;\n      display: flex;\n    } "]}]}],o.ctorParameters=function(){return[{type:s}]},o.propDecorators={max:[{type:t.Input}],animate:[{type:t.Input}],striped:[{type:t.Input}],type:[{type:t.Input}],value:[{type:t.Input}]};var i=function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e}();i.decorators=[{type:t.NgModule,args:[{imports:[n.CommonModule],declarations:[a,o],exports:[a,o]}]}],e.BarComponent=a,e.ProgressbarComponent=o,e.ProgressbarConfig=s,e.ProgressbarModule=i,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=ngx-bootstrap-progressbar.umd.min.js.map